# https://gist.github.com/mtigas/952344

# terminology
#	certificate														    :	The public half of a public/private key pair with some additional metadata about who issued it etc.
#	x.509																A specification governing the format and usage of certificates.

#	certificate authority													    :	A company (Symantec/Verisign/Thawte,Comodo,GoDaddy) that issues digital certificates.
																	These certs are included by most browsers and operating systems.
																	Serve purpose of a trusted third party

#	Certificate Signing Request (CSR)											    :	A file generated with a private key
																	A CSR can be sent to a CA to request to be signed. 
																	The CA uses its private key to digitally sign the CSR and create a signed cert. 
																	Browsers can then use the CA’s cert to validate the new cert has been approved by the CA.

# File formats for Certs and Keys

#   Privacy-Enhanced Mail (PEM)
#	PEM is just Distinguished Encoding Rules (DER) that has been Base64 encoded. Used for keys and certificates.

#  PKCS12
#	PKCS12 is a password-protected format that can contain multiple certificates and keys.

#  Java KeyStore (JKS)
#	Java version of PKCS12 and also password protected. 
#	Entries in a JKS file must have an “alias” that is unique. 
#	If an alias is not specified, “mykey” is used by default. It’s like a database for certs and keys.


#Two-way SSL authentication (server <-> client)
# Client and server use 12 handshake messages to establish the encrypted channel prior to message exchanging:
# 1) Client sends ClientHello message proposing SSL options.
# 2) Server responds with ServerHello message selecting the SSL options.
# 3) Server sends Certificate message, which contains the server’s certificate.
# 4) Server requests client’s certificate in CertificateRequest message, so that the connection can be mutually authenticated.
# 5) Server concludes its part of the negotiation with ServerHelloDone message.
# 6) Client responds with Certificate message, which contains the client’s certificate.
# 7) Client sends session key information (encrypted with server’s public key) in ClientKeyExchange message.
# 8) Client sends a CertificateVerify message to let the server know it owns the sent certificate.
# 9) Client sends ChangeCipherSpec message to activate the negotiated options for all future messages it will send.
# 10) Client sends Finished message to let the server check the newly activated options.
# 11) Server sends ChangeCipherSpec message to activate the negotiated options for all future messages it will send.
# 12) Server sends Finished message to let the client check the newly activated options.

# Setup procedure
#   openssl genrsa -des3 -out gpteserver.key 4096                                                                                   :   generate gpteserver.key
#   openssl req -new -x509 -days 365 -key gpteserver.key -out gpteserver.crt                                                        :   generate certificate aauthority root (ensure "common name" is populated with FQDN of server) 
#   openssl x509 -in gpteserver.crt -text -noout                                                                                    :   inspect server certificate
#
#   openssl genrsa -des3 -out gpteclient.key 4096                                                                                   :   generate gpteclient.key
#   openssl req -new -key gpteclient.key -out gpteclient.csr                                                                        :   create certificate signing request using client key (no need to specify a challenge password)
#   openssl x509 -req -days 365 -in gpteclient.csr -CA gpteserver.crt -CAkey gpteserver.key -set_serial 01 -out gpteclient.crt      :   create client cert by self-signing using server cert and key
#   openssl pkcs12 -export -clcerts -in gpteclient.crt -inkey gpteclient.key -out gpteclient.p12                                    :   convert to PKCS format (so that it may be installed on most browsers)
#   openssl pkcs12 -in gpteclient.p12 -out gpteclient.pem -clcerts                                                                  :   Combines client.crt and client.key into a single PEM file for programs using openssl.

# no client cert provided       :       curl -v -k -X GET https://localhost/gpte-reporting/rest/sanityCheck/
#       expected results        :       NSS: client certificate not found (nickname not specified)


# client cert provided          :       curl --cert ~/.certs/gpteclient.pem:jb0ssredhat! --key ~/.certs/gpteclient.key -v -k -X GET https://localhost/gpte-reporting/rest/sanityCheck/

#  openssl s_client -showcerts -connect localhost:443 -key gpteclient.key                                                          :   establish a transparent connection with server using TLS


#SSLCACertificateFile "/home/jbride-redhat.com/.certs/gpteserver.crt"
SSLCACertificateFile "/home/jbride-redhat.com/.certs/ca.crt"
#SSLCACertificateFile "/home/jbride-redhat.com/.certs/dev.opentlc.com.cert"

<Location /gpte-reporting>

  # require a client certificate which has to be directly signed by our CA cert in ca.crt
  SSLVerifyClient require
  SSLVerifyDepth 1

  ProxyPass http://localhost:8205/gpte-reporting
  ProxyPassReverse http://localhost:8205/gpte-reporting
  Order allow,deny
  Allow from all
</Location>
